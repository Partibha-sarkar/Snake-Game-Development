// snake_sfml.cpp
// Requires SFML (graphics + audio)
#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <vector>
#include <deque>
#include <random>
#include <string>

const int WINDOW_W = 800;
const int WINDOW_H = 600;
const int CELL_SIZE = 20;
const int COLS = WINDOW_W / CELL_SIZE;
const int ROWS = WINDOW_H / CELL_SIZE;

struct Cell { int x, y; };

enum Direction { Up, Down, LeftDir, RightDir };

std::mt19937 rng(std::random_device{}());

Cell randomCellExcluding(const std::deque<Cell>& exclude) {
    std::uniform_int_distribution<int> dx(0, COLS - 1);
    std::uniform_int_distribution<int> dy(0, ROWS - 1);
    Cell c;
    bool ok = false;
    while (!ok) {
        c.x = dx(rng);
        c.y = dy(rng);
        ok = true;
        for (auto &e : exclude) if (e.x == c.x && e.y == c.y) { ok = false; break; }
    }
    return c;
}

int main() {
    sf::RenderWindow window(sf::VideoMode(WINDOW_W, WINDOW_H), "Snake - SFML");
    window.setFramerateLimit(60);

    // Load sounds (optional files)
    sf::SoundBuffer eatBuf, overBuf;
    sf::Sound eatSound, overSound;
    bool soundLoaded = false;
    if (eatBuf.loadFromFile("eat.wav") && overBuf.loadFromFile("gameover.wav")) {
        eatSound.setBuffer(eatBuf);
        overSound.setBuffer(overBuf);
        soundLoaded = true;
    }

    // Game state
    std::deque<Cell> snake;
    snake.push_back({COLS/2, ROWS/2});
    snake.push_back({COLS/2 - 1, ROWS/2});
    Direction dir = RightDir;
    bool alive = true;
    int score = 0;

    Cell food = randomCellExcluding(snake);

    // Visuals
    sf::RectangleShape rect(sf::Vector2f(CELL_SIZE - 1, CELL_SIZE - 1));
    sf::Font font;
    bool fontLoaded = font.loadFromFile("Arial.ttf"); // optional; fallback if not present

    sf::Text hud;
    if (fontLoaded) {
        hud.setFont(font);
        hud.setCharacterSize(18);
        hud.setFillColor(sf::Color::White);
        hud.setPosition(5, 5);
    }

    // Timing for movement (in seconds). Starts slower; decreases to increase speed.
    float moveInterval = 0.14f; // 140 ms per cell (easy)
    sf::Clock moveClock;

    while (window.isOpen()) {
        // --- Input ---
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) window.close();
            if (event.type == sf::Event::KeyPressed) {
                if (event.key.code == sf::Keyboard::Up && dir != Down) dir = Up;
                else if (event.key.code == sf::Keyboard::Down && dir != Up) dir = Down;
                else if (event.key.code == sf::Keyboard::Left && dir != RightDir) dir = LeftDir;
                else if (event.key.code == sf::Keyboard::Right && dir != LeftDir) dir = RightDir;
                else if (event.key.code == sf::Keyboard::R && !alive) {
                    // restart
                    snake.clear();
                    snake.push_back({COLS/2, ROWS/2});
                    snake.push_back({COLS/2 - 1, ROWS/2});
                    dir = RightDir;
                    alive = true;
                    score = 0;
                    moveInterval = 0.14f;
                    food = randomCellExcluding(snake);
                    moveClock.restart();
                }
            }
        }

        // --- Update (movement by timer) ---
        if (alive && moveClock.getElapsedTime().asSeconds() >= moveInterval) {
            moveClock.restart();
            Cell head = snake.front();
            Cell newHead = head;
            if (dir == Up) newHead.y -= 1;
            else if (dir == Down) newHead.y += 1;
            else if (dir == LeftDir) newHead.x -= 1;
            else if (dir == RightDir) newHead.x += 1;

            // check wall collision -> game over
            if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) {
                alive = false;
                if (soundLoaded) overSound.play();
            } else {
                // check self collision
                bool hitSelf = false;
                for (auto &seg : snake) if (seg.x == newHead.x && seg.y == newHead.y) { hitSelf = true; break; }
                if (hitSelf) {
                    alive = false;
                    if (soundLoaded) overSound.play();
                } else {
                    // move snake
                    snake.push_front(newHead);
                    // check food
                    if (newHead.x == food.x && newHead.y == food.y) {
                        score++;
                        if (soundLoaded) eatSound.play();
                        // increase speed slightly every time (difficulty)
                        moveInterval = std::max(0.03f, moveInterval - 0.007f); // cap minimum
                        // spawn new food
                        food = randomCellExcluding(snake);
                    } else {
                        // remove tail
                        snake.pop_back();
                    }
                }
            }
        }

        // --- Render ---
        window.clear(sf::Color(40, 40, 40)); // background

        // draw food
        rect.setFillColor(sf::Color::Red);
        rect.setPosition(food.x * CELL_SIZE + 0.5f, food.y * CELL_SIZE + 0.5f);
        window.draw(rect);

        // draw snake
        bool first = true;
        for (auto &seg : snake) {
            rect.setPosition(seg.x * CELL_SIZE + 0.5f, seg.y * CELL_SIZE + 0.5f);
            if (first) {
                rect.setFillColor(sf::Color::Green);
                first = false;
            } else rect.setFillColor(sf::Color(90, 200, 90));
            window.draw(rect);
        }

        // HUD
        if (fontLoaded) {
            hud.setString("Score: " + std::to_string(score) + "    Speed: " + std::to_string((int)(1.0f/moveInterval)) + "    (R to restart)");
            window.draw(hud);
        } else {
            // If font not loaded, we can do nothing or load another font file.
        }

        // Game over text
        if (!alive) {
            sf::Text goText;
            if (fontLoaded) {
                goText.setFont(font);
                goText.setCharacterSize(48);
                goText.setFillColor(sf::Color::Yellow);
                goText.setStyle(sf::Text::Bold);
            }
            goText.setString("GAME OVER\nPress R to restart");
            goText.setPosition(WINDOW_W/2 - 180, WINDOW_H/2 - 50);
            window.draw(goText);
        }

        window.display();
    }

    return 0;
}
